<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/core-icons/core-icons.html" />
<link rel="import" href="../../bower_components/core-icon-button/core-icon-button.html" />
<link rel="import" href="../../bower_components/core-icon/core-icon.html" />
<link rel="import" href="../../bower_components/core-ajax/core-ajax.html" />

<script src="../../bower_components/vis/dist/vis.min.js"></script>

<polymer-element name="octopus-chart-static" attributes="streams width height timezero dataurl">
<template>
<link rel="stylesheet" href="../../bower_components/vis/dist/vis.min.css" />
<link rel="stylesheet" href="octopus-chart.css" />

<core-ajax
	id="data"
    auto
    url="{{fetchDataURL}}"
    handleAs="json"
    on-core-response="{{loadedData}}"></core-ajax>

<div id="box" style="width: {{ width + 10 }}px;">
	<div id="chart" style="width: {{ width }}px; height: {{ height }}px;"></div>
	<div style="text-align: right">
		<core-icon icon="settings" on-click="{{ toggleOptions }}"></core-icon>
		<core-icon icon="undo" on-click="{{ resetZoom }}"></core-icon>
	</div>
	<div id="options">
		<div><strong>Variables:</strong></div>
		<ul style="list-style-type: none;">
		<template repeat="{{ s in streams }}">
			<li>{{ s.name }} <button on-click="{{ removeStream }}" data-name="{{ s.key }}">Remove</button></li>
		</template>
		</ul>
		<div style="text-align: right">
			<core-icon-button icon="cancel" on-click="{{ removeChart }}"> Remove Chart</core-icon-button>
		</div>
	</div>
</div>

</template>
<script>

Polymer('octopus-chart-static', {
	width: 600, // Of the chart, in pixels
	height: 400, // Of the chart, in pixels
	dataurl: '',
	streams: [],

	created: function () {
		this._data = {};
		this._series = [];
		this.unit = null;
	},

	ready: function () {
		var _this = this;
		this.groups = new vis.DataSet();
		this.seriesdata = new vis.DataSet({
			queue: {
				delay: 10
			}
		});
		var graph = new vis.Graph2d(this.$.chart, this.seriesdata, this.groups, {
			height: this.height,
			width: this.width,
			showCurrentTime: false,
			//min: vis.moment.unix(this.timezero),
			defaultGroup: 'ungrouped',
			legend: true,
			drawPoints: false,
			catmullRom: false
		});

		function debounce (func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) func.apply(context, args);
				};
				var callNow = immediate && !timeout;
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
				if (callNow) func.apply(context, args);
			};
		};

		graph.on('rangechanged', debounce(function (range) {
			var mainRange = graph.getItemRange();

			// Check there's a decent zoom
			if ((range.end - range.start) / (mainRange.max - mainRange.min) > 0.9) {
				return;
			}

			var newRange = (range.end - range.start);
			var minRangeInArea = _this.seriesdata.get({
				fields: ['density'],
				filter: function (item) {
					return item.x > range.start && item.x < range.end;
				},
				order: 'density'
			});

			if (minRangeInArea.length && newRange >= minRangeInArea[0].density) {
				return;
			}

			_this.getData(range);
		}, 500));
		this.graph = graph;
	},

	toggleOptions: function (e) {
		$(e.srcElement).toggleClass("active");
		$(this.$.options).toggleClass("show");
	},

	/*removeStream: function (e) {
		var key = $(e.target).data("name");

		for (i = 0, m = this.streams.length; i < m; i++) {
			if (this.streams[i].key === key) {
				this.streams.splice(i, 1);
				break;
			}
		}
	},*/

	removeChart: function (e) {
		this.fire("remove-chart");
	},

	_groupCounter: 0,
	_findGroupIdByName: function (name) {
		var ids = this.groups.getIds({
			filter: function (item) {
				return item.key === name;
			}
		});

		return ids[0];
	},

	streamsChanged: function (oldStreams) {
		var _this = this;
		var newStreams = this.streams;

		// Make sure newStreams contains only unique items
		for (var i = 0; i < newStreams.length; i++)
			for (var j = i + 1; j < newStreams.length; j++)
				if (newStreams[i] === newStreams[j])
					newStreams.splice(j--, 1);

		// Find streams that have been removed, discard data.
		oldStreams.filter(function(obj) {
			return !newStreams.some(function(obj2) {
				return obj.key === obj2.key;
			});
		}).forEach(function (name) {
			//delete _this._data[name];
			var id = _this._findGroupIdByName(name);
			if (id) {
				_this.groups.remove(id);
				_this.seriesdata.remove(_this.seriesdata.getIds({
					filter: function (item) {
						return item.group === id;
					}
				}));
			}
		});

		// Find streams that have been added
		var addedStreams = newStreams.filter(function(obj) {
			return !oldStreams.some(function(obj2) {
				return obj.key === obj2.key;
			});
		});

		// Set up this._series
		var zero, stream, series = [];

		for (i = 0, m = newStreams.length; i < m; i++) {
			stream = newStreams[i];

			if (this.unit === null) {
				this.unit = stream.unit;
				this.graph.setOptions({
					dataAxis: { title: { left: { text: this.unit }}}
				});
			} else if (this.unit !== stream.unit) {
				console.log("mismatched units: ", this.unit, stream);
			}

			this.groups.add({
				id: ++this._groupCounter,
				content: stream.name,
				key: stream.key
			});

			//series[i] = stream.name; //{
				//color: stream.colour,
				//data: this._data[stream.key] || [],
				//label: stream.name
			//};
		}

		//this._series = series;
		//this.groupNames = series;

		this.getData();
	},

	widthChanged: function () {
		this.redraw();
	},

	heightChanged: function () {
		this.redraw();
	},

	redraw: function () {
	},

	_idCounter: 0,
	_firstLoad: true,
	loadedData: function (e, detail) {
		var data = detail.response;
		var id, name, density, streamData;
		for (var i = 0, m = data.length; i < m; i++) {
			name = data[i].name;
			id = this._findGroupIdByName(name);
			if (typeof id !== "undefined") {
				streamData = data[i].data;
				max = streamData[streamData.length - 1][0] * 1000;
				min = streamData[0][0] * 1000;
				density = max - min;

				this.seriesdata.remove(this.seriesdata.getIds({
					filter: function (item) {
						return item.x > min && item.x < max;
					}
				}));

				for (var j = 0, n = streamData.length; j < n; j++) {
					this.seriesdata.add({
						id: this._idCounter++,
						x: vis.moment.unix(this.timezero + streamData[j][0]),
						y: streamData[j][1],
						group: id,
						density: density
					});
				}
			}
		}

		this.seriesdata.flush();
		var graph = this.graph;
		var range = graph.getItemRange();
		graph.setOptions({
			max: range.max,
			min: range.min
		});

		if (this._firstLoad) {
			graph.fit();
			this._firstLoad = false;
		}
	},

	getData: function (range) {
		var url = [this.dataurl, '?'];
		var params = [];

		Array.prototype.push.apply(params, this.groups.map(
			function (s) { return "var=" + encodeURIComponent(s.key); }
		));

		if (typeof range !== "undefined") {
			params.push("start=" + (Math.round(range.start / 1000) - this.timezero));
			params.push("interval=" + (Math.round((range.end - range.start) / 1000)));
		}

		this.$.data.url = url.join('') + params.join('&');
	}
});

</script>
</polymer-element>
