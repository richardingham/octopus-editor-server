<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/core-icons/core-icons.html" />
<link rel="import" href="../../bower_components/core-icon-button/core-icon-button.html" />
<link rel="import" href="../../bower_components/core-icon/core-icon.html" />
<link rel="import" href="../../bower_components/core-ajax/core-ajax.html" />

<script src="jquery.offset.fix.js"></script>
<script src="jquery.flot.min.js"></script>
<script src="jquery.flot.selection.min.js"></script>
<script src="jquery.flot.axislabels.js"></script>
<script src="jintervals-0.7-min.js"></script>

<polymer-element name="octopus-chart-static" attributes="streams width height timezero dataurl">
<template>
<style>

:host {
	display: block;
	margin: 5px;
}

#box {
	background-color: #D5DEED;
	border-radius: 2px;
	padding: 5px;
}

#options {
	display: none;
	padding: 5px;
	font-size: 0.8em;
}

#options.show {
	display: block;
}

#box core-icon {
	color: #3E57A1;
	cursor: pointer;
}

#box core-icon.active,
#box core-icon:hover {
	color: #000;
}

#options core-icon-button {
	color: #CD4848;
}
#options core-icon-button:hover {
	color: #E22200
}

</style>

<core-ajax
	id="data"
    auto
    url="{{fetchDataURL}}"
    handleAs="json"
    on-core-response="{{loadedData}}"></core-ajax>

<div id="box" style="width: {{ width + 10 }}px;">
	<div id="chart" style="width: {{ width }}px; height: {{ height }}px;"></div>
	<div id="options">
		<div><strong>Variables:</strong></div>
		<ul style="list-style-type: none;">
		<template repeat="{{ s in streams }}">
			<li>{{ s.name }} <button on-click="{{ removeStream }}" data-name="{{ s.key }}">Remove</button></li>
		</template>
		</ul>
		<div style="text-align: right">
			<core-icon-button icon="cancel" on-click="{{ removeChart }}"> Remove Chart</core-icon-button>
		</div>
	</div>
</div>

</template>
<script>

Polymer('octopus-chart-static', {
	width: 600, // Of the chart, in pixels
	height: 400, // Of the chart, in pixels
	dataurl: '',
	streams: [],

	created: function () {
		this._data = {};
		this._series = [];
		this.unit = null;
	},

	ready: function () {
		var _this = this;
		$(this.$.chart).on("plotselected", function (event, ranges) {
			if (ranges.xaxis.to - ranges.xaxis.from > 1) {
				_this.getData(ranges.xaxis);
			}
			_this._plot.clearSelection();
		})
	},

	toggleOptions: function (e) {
		$(e.srcElement).toggleClass("active");
		$(this.$.options).toggleClass("show");
	},

	removeStream: function (e) {
		var key = $(e.target).data("name");

		for (i = 0, m = this.streams.length; i < m; i++) {
			if (this.streams[i].key === key) {
				this.streams.splice(i, 1);
				break;
			}
		}
	},

	removeChart: function (e) {
		this.fire("remove-chart");
	},

	streamsChanged: function (oldStreams) {
		var _this = this;
		var newStreams = this.streams;

		// Make sure newStreams contains only unique items
		for (var i = 0; i < newStreams.length; i++)
			for (var j = i + 1; j < newStreams.length; j++)
				if (newStreams[i] === newStreams[j])
					newStreams.splice(j--, 1);

		// Find streams that have been removed, discard data.
		oldStreams.filter(function(obj) {
			return !newStreams.some(function(obj2) {
				return obj.key === obj2.key;
			});
		}).forEach(function (name) {
			delete _this._data[name];
		});

		// Find streams that have been added
		var addedStreams = newStreams.filter(function(obj) {
			return !oldStreams.some(function(obj2) {
				return obj.key === obj2.key;
			});
		});

		// Set up this._series
		var zero, stream, series = [];

		for (i = 0, m = newStreams.length; i < m; i++) {
			stream = newStreams[i];

			if (this.unit === null) {
				this.unit = stream.unit;
			} else if (this.unit !== stream.unit) {
				console.log("mismatched units: ", this.unit, stream);
			}

			series[i] = {
				color: stream.colour,
				data: this._data[stream.key] || [],
				label: stream.name
			};
		}

		this._series = series;

		// Request data for added streams.
		if (addedStreams.length) {
			this.fire("request-data", {
				streams: addedStreams.map(function (s) { return s.key; }),
				start: +(new Date()) - (this.time * 1000)
			});
		}

		// Draw the new chart
		var _this = this;

		var options = {
			axisLabels: {
				show: true
			},
			yaxis: {
				axisLabel: this.unit
				//min: 0,
				//max: 10
			},
			xaxis: {
				//min: trace_zero,
				//max: x_max,
				axisLabel: "Time",
				tickFormatter: function (d) {
					return (d >= 0 ? "" : "-") + jintervals(Math.round(Math.abs(d)), "{HH?:}{mm}:{ss}");
				}
			},
			legend: {
				position: "nw",
				show: true
			},
			grid: {
				backgroundColor: "#FFF"
			},
			selection: {
				mode: "x",
				minSize: 10
			}
		};

		this._plot = $.plot(this.$.chart, this._series, options);
		this.getData()
	},

	widthChanged: function () {
		this.redraw();
	},

	heightChanged: function () {
		this.redraw();
	},

	redraw: function () {
		this._plot.setData(this._series);
		this._plot.setupGrid();
		this._plot.draw();
	},

	loadedData: function (e, detail) {
		var name, series = this._series, n = series.length, data = detail.response;
		for (var i = 0, m = data.length; i < m; i++) {
			name = data[i].name;
			for (var j = 0; j < n; j++) {
				if (series[j].label === name) {
					series[j].data = data[i].data;
				}
			}
		}

		this.redraw();
	},

	getData: function (range) {
		var url = [this.dataurl, '?'];
		var params = [];

		Array.prototype.push.apply(params, this.streams.map(
			function (s) { return "var=" + encodeURIComponent(s.key); }
		));

		if (typeof range !== "undefined") {
			params.push("start=" + Math.round(range.from * 100) / 100);
			params.push("interval=" + Math.round((range.to - range.from) * 100) / 100);
			params.push("step=" + Math.round((range.to - range.from) / 50 * 1000) / 1000);
		}

		this.$.data.url = url.join('') + params.join('&');
	}
});

</script>
</polymer-element>
