<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/core-icons/core-icons.html" />
<link rel="import" href="../../bower_components/core-icon-button/core-icon-button.html" />
<link rel="import" href="../../bower_components/core-icon/core-icon.html" />

<!--script src="jquery.flot.min.js"></script>
<script src="jintervals-0.7-min.js"></script-->
<script src="vis.min.js"></script>

<polymer-element name="octopus-chart" attributes="streams width height time timezero">
<template>
<link rel="stylesheet" href="vis.min.css" />
<style>

:host {
	display: block;
	margin: 5px;
}

#box {
	background-color: #D5DEED;
	border-radius: 2px;
	padding: 5px;
}

#chart {
	background-color: #FFF;
}

#options {
	display: none;
	padding: 5px;
	font-size: 0.8em;
}

#options.show {
	display: block;
}

#box core-icon {
	color: #3E57A1;
	cursor: pointer;
}

#box core-icon.active,
#box core-icon:hover {
	color: #000;
}

#options core-icon-button {
	color: #CD4848;
}
#options core-icon-button:hover {
	color: #E22200
}

</style>

<div id="box" style="width: {{ width + 10 }}px;">
	<div id="chart" style="width: {{ width }}px; height: {{ height }}px;"></div>
	<div style="text-align: right">
		<core-icon icon="settings" on-click="{{ toggleOptions }}"></core-icon>
	</div>
	<div id="options">
		<div>
			Scale: <input type="text" value="{{ time }}" style="width: 50px;"> seconds
		</div>
		<div><strong>Variables:</strong></div>
		<ul style="list-style-type: none;">
		<template repeat="{{ s in streams }}">
			<li>{{ s.name }} <button on-click="{{ removeStream }}" data-name="{{ s.key }}">Remove</button></li>
		</template>
		</ul>
		<div style="text-align: right">
			<core-icon-button icon="cancel" on-click="{{ removeChart }}"> Remove Chart</core-icon-button>
		</div>
	</div>
</div>

</template>
<script>

Polymer('octopus-chart', {
	width: 600, // Of the chart, in pixels
	height: 400, // Of the chart, in pixels
	time: 60, // In seconds
	timezero: 0,
	streams: [],

	created: function () {
		this._data = {};
		this._series = [];
		this.unit = null;
	},

	ready: function () {
		var _this = this;
		this.groups = new vis.DataSet();
		this.seriesdata = new vis.DataSet({
			queue: {
				delay: 10
			}
		});
		var graph = new vis.Graph2d(this.$.chart, this.seriesdata, this.groups, {
			height: this.height,
			width: this.width,
			showCurrentTime: true,
			//min: vis.moment.unix(this.timezero),
			defaultGroup: 'ungrouped',
			legend: {
				left: {
					position: "bottom-left"
				}
			},
			drawPoints: false,
			catmullRom: false
		});

		var now = vis.moment();
		graph.setWindow(now, now + 60 * 1000);

		this.graph = graph;
	},

	toggleOptions: function (e) {
		$(e.srcElement).toggleClass("active");
		$(this.$.options).toggleClass("show");
	},

	removeStream: function (e) {
		var key = $(e.target).data("name");

		for (i = 0, m = this.streams.length; i < m; i++) {
			if (this.streams[i].key === key) {
				this.streams.splice(i, 1);
				break;
			}
		}
	},

	removeChart: function (e) {
		this.fire("remove-chart");
	},

	_groupCounter: 0,
	_findGroupIdByName: function (name) {
		var ids = this.groups.getIds({
			filter: function (item) {
				return item.key === name;
			}
		});

		return ids[0];
	},

	streamsChanged: function (oldStreams) {
		var _this = this;
		var newStreams = this.streams;

		// Make sure newStreams contains only unique items
		for (var i = 0; i < newStreams.length; i++)
			for (var j = i + 1; j < newStreams.length; j++)
				if (newStreams[i] === newStreams[j])
					newStreams.splice(j--, 1);

		// Find streams that have been removed, discard data.
		oldStreams.filter(function(obj) {
			return !newStreams.some(function(obj2) {
				return obj.key === obj2.key;
			});
		}).forEach(function (name) {
			//delete _this._data[name];
			var id = _this._findGroupIdByName(name);
			if (id) {
				_this.groups.remove(id);
				_this.seriesdata.remove(_this.seriesdata.getIds({
					filter: function (item) {
						return item.group === id;
					}
				}));
			}
		});

		// Find streams that have been added
		var addedStreams = newStreams.filter(function(obj) {
			return !oldStreams.some(function(obj2) {
				return obj.key === obj2.key;
			});
		});

		// Set up this._series
		var zero, stream, series = [];

		for (i = 0, m = newStreams.length; i < m; i++) {
			stream = newStreams[i];

			if (this.unit === null) {
				this.unit = stream.unit;
				this.graph.setOptions({
					dataAxis: { title: { left: { text: this.unit }}}
				});
			} else if (this.unit !== stream.unit) {
				console.log("mismatched units: ", this.unit, stream);
			}

			this.groups.add({
				id: ++this._groupCounter,
				content: stream.name,
				key: stream.key
			});

			//series[i] = {
				//color: stream.colour,
				//data: this._data[stream.key] || [],
				//label: stream.name
			//};
		}

		//this._series = series;

		// Request data for added streams.
		if (addedStreams.length) {
			this.fire("request-data", {
				streams: addedStreams.map(function (s) { return s.key; }),
				start: +(new Date()) - (this.time * 1000)
			});
		}

	},

	_idCounter: 0,
	addData: function (data) {
		var streamName, streamData, streamGroup;
		var i, j, m, n;

		// Loop over each stream in the provided data packet
		for (var i = 0, m = data.length; i < m; i++) {
			streamName = data[i].name;
			streamGroup = this._findGroupIdByName(streamName);
			if (typeof streamGroup !== "undefined") {
				streamData = data[i].data;
				for (var j = 0, n = streamData.length; j < n; j++) {
					this.seriesdata.add({
						id: ++this._idCounter,
						x: vis.moment.unix(streamData[j][0]),
						y: streamData[j][1],
						group: streamGroup
					});
				}
			}
		}

		var now = vis.moment();
		var range = this.graph.getWindow();
		var interval = range.end - range.start;
		if (now > range.end) {
			this.graph.setWindow(now - 0.1 * interval, now + 0.9 * interval);
		}
	},

	/*widthChanged: function () {
		this.redraw();
	},

	heightChanged: function () {
		this.redraw();
	},*/

	timeChanged:  function () {
		// Request data for added streams.
		this.fire("request-data", {
			streams: (self.streams && self.streams.map(function (s) { return s.key; })) || [],
			start: (+(new Date()) / 1000) - this.time
		});
	},

	redraw: function () {
	}
});

</script>
</polymer-element>
