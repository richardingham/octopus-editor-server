<link rel="import" href="../../bower_components/polymer/polymer.html">
<script src="jquery.flot.min.js"></script>
<script src="jintervals-0.7-min.js"></script>

<polymer-element name="octopus-chart" attributes="streams width height time timezero">
<style>

:host {
	display: block;
}

</style>
<template>
	<div id="chart" style="width: {{ width }}px; height: {{ height }}px;"></div>
	<div>
		Scale: <input type="text" value="{{ time }}" style="width: 50px;"> seconds
	</div>
</template>
<script>

Polymer('octopus-chart', {
	width: 600, // Of the chart, in pixels
	height: 400, // Of the chart, in pixels
	time: 60, // In seconds
	timezero: 0,
	streams: [],

	_data: {},
	_series: [],
	unit: null,

	streamsChanged: function (oldStreams) {
		var _this = this;
		var newStreams = this.streams;

		// Make sure newStreams contains only unique items
		for (var i = 0; i < newStreams.length; i++)
			for (var j = i + 1; j < newStreams.length; j++)
				if (newStreams[i] === newStreams[j])
					newStreams.splice(j--, 1);

		// Find streams that have been removed, discard data.
		oldStreams.filter(function(obj) {
			return !newStreams.some(function(obj2) {
				return obj.name === obj2.name;
			});
		}).forEach(function (name) {
			delete _this._data[name];
		});

		// Find streams that have been added
		var addedStreams = newStreams.filter(function(obj) {
			return !oldStreams.some(function(obj2) {
				return obj.name === obj2.name;
			});
		});

		// Set up this._series
		var zero, stream, series = [];

		for (i = 0, m = newStreams.length; i < m; i++) {
			stream = newStreams[i];

			if (this.unit === null) {
				this.unit = stream.unit;
			} else if (this.unit !== stream.unit) {
				console.log("mismatched units: ", this.unit, stream);
			}

			series[i] = {
				color: stream.colour,
				data: this._data[stream.name],
				label: stream.name
			};
		}

		this._series = series;

		// Request data for added streams.
		if (addedStreams.length) {
			this.fire("request-data", {
				streams: addedStreams.map(function (s) { return s.name; }),
				start: (+(new Date()) / 1000) - this.time
			});
		}

		// Draw the new chart
		var _this = this;

		var options = {
			yaxis: {
				//min: 0,
				//max: 10
			},
			xaxis: {
				//min: trace_zero,
				//max: x_max,
				transform: function (v) { return v - _this.timezero; },
				inverseTransform: function (v) { return v + _this.timezero; },
				//tickFormatter: relative_time
				tickFormatter: function (d) {
					if (_this.timezero === 0) {
						return (new Date(d * 1000)).toTimeString().substr(0, 8);
					} else {
						d -= _this.timezero;
						return (d >= 0 ? "" : "-") + jintervals(Math.round(Math.abs(d)), "{HH?:}{mm}:{ss}");
					}
				}
			},
			legend: {
				position: "nw",
				show: true
			}			
		};

		this._plot = $.plot(this.$.chart, this._series, options);
	},

	addData: function (data, zero) {
		var name, newData, newDataZero;
		var streamData;
		var i, j, m, n;
		var maxTime = 0;

		// For each stream in this chart
		for (i = 0, m = this.streams.length; i < m; i++) {
			name = this.streams[i].name;
			newData = data[name];

			// Check if there is new data for this stream
			if (typeof newData === "undefined" || !newData.length) {
				continue;
			}

			// Fix the time in the data
			newData = newData.map(function (p) {
				p[0] = (p[0] + zero) / 1000;
				return p;
			});
			maxTime = Math.max(maxTime, newData[newData.length - 1][0]);

			// Figure out if any of the data points are repeated.
			// Remove repeats.
			streamData = this._data[name] || [];
			newDataZero = newData[0][0];

			for (j = 0, n = streamData.length; j < n; j++) {
				if (streamData[j][0] >= newDataZero) {
					streamData.splice(j, n - j);
					break;
				}
			}

			// Append new data.
			this._data[name] = streamData.concat(newData);
		}

		var desiredDataZero = maxTime - this.time;
		var p0, p1, p2;

		// Trim data off start of stream.
		for (i = 0, m = this.streams.length; i < m; i++) {
			streamData = this._data[this.streams[i].name];

			for (j = 1, n = streamData.length; j < n; j++) {
				// Interpolate point at desiredDataZero
				if (streamData[j][0] >= desiredDataZero) {
					// Exact point
					if (streamData[j][0] === desiredDataZero) {
						streamData.splice(0, j);
						break;
					}

					p0 = streamData[j - 1];
					p1 = streamData[j];

					if (p0[0] == p1[0]) {
						p2 = p1[1];
					} else {
						p2 = p0[1] + (p1[1] - p0[1]) * (desiredDataZero - p0[0]) / (p1[0] - p0[0]);
					}

					streamData.splice(0, j, [desiredDataZero, p2]);
					break;
				}
			}

			//this._data[name] = streamData;
			this._series[i].data = streamData;
		}

		// plot_start = Math.max(earliest_desired_time, first_point);

		// plot.getOptions().xaxes[0].min = first_point;
		// plot.getOptions().xaxes[0].max = Math.max(data_max_time, first_point + min_display_time);

		this.redraw();
	},

	widthChanged: function () {
		this.redraw();
	},

	heightChanged: function () {
		this.redraw();
	},

	timeChanged:  function () {
		// Request data for added streams.
		this.fire("request-data", {
			streams: self.streams.map(function (s) { return s.name; }),
			start: (+(new Date()) / 1000) - this.time
		});
	},

	redraw: function () {
		this._plot.setData(this._series);
		this._plot.setupGrid();
		this._plot.draw();
	}
});

</script>
</polymer-element>
